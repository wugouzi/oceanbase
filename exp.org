#+title: 一点经验

坑: 如果想使用多线程写sstable，对应的ObMacroBlockWriter得在当前线程内open与close，不然会出错。

解题思路：
为了提高排序的速度，我们的思路是在读取文件的时候，把每一行数据根据键值大小写到不同的桶文件中，那么只
要数量足够多，就能够在内存中直接把桶文件的数据排好序



* PPT

** 团队介绍

** 题目分析

***

** 优化思路

*** 改进排序
    原来的外部归并排序比较慢，有几个原因：
    1. 单线程（主要）
    2. 需要大量的IO
    但是不好修改，因此自己写了一个外部排序，目标：
    1. 尽可能少的IO
    2. 尽量在内存中进行排序
    因此我使用了桶排序
    * 首先第一次读取文件，将文件按键值大小将每一行写进对应的临时文件，保证每个文件都足够小，能够一次性读进内存
      并进行排序。

      通过二分搜索加速这个过程。

      在写临时文件的时候，因为瓶颈主要在IO上，因此可以通过压缩的方法减少写的数据量，提升很大（24%）

    * 读取临时文件，根据键值排好序后进行格式转换跟写表。

    优点：
    * 排序只需要读两次，写一次，IO次数较少
    * 易于并行化
    * 提升100%
*** 并行化

    并行读没有效果

    并行写有效果，现在瓶颈在CPU上
*** 优化Caster
*** 小优化


** 总结分析
    1.
** 提升
    | 59bc | 595861 | improve read                        |      |
    | d7e9 | 587042 | simplies cast                       | 3.4% |
    | 7cf1 | 567588 | no decompress                       | 7.5% |
    | ob2e | 527815 | unfold for                          | 2.8% |
    | 7d5b | 513613 | use 8 thread, sort in single thread | 7.1% |
    | 1333 | 479397 | string_string no copy               | 2.1% |
    | 3fac | 469513 | disable checks in cast              | 3.3% |
    | f846 | 454281 | in memory new row for sort          | 175%, 15.6% |
    | 2c8d | 393007 | bucket sort                         | 136% |
    | a37f | 165165 |                                     |      |
    | ef36 | 135713 |                                     |      |
