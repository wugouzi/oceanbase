#+title: 一点经验

坑: 如果想使用多线程写sstable，对应的ObMacroBlockWriter得在当前线程内open与close，不然会出错。

解题思路：
为了提高排序的速度，我们的思路是在读取文件的时候，把每一行数据根据键值大小写到不同的桶文件中，那么只
要数量足够多，就能够在内存中直接把桶文件的数据排好序



* PPT

** 团队介绍

** 题目分析

***

** 优化思路

*** 改进排序
    原来的外部归并排序比较慢，有几个原因：
    1. 单线程（主要）
    2. 需要大量的IO
    但是不好修改，因此自己写了一个外部排序，目标：
    1. 尽可能少的IO
    2. 尽量在内存中进行排序
    因此我使用了桶排序
    * 首先第一次读取文件，将文件按键值大小将每一行写进对应的临时文件，保证每个文件都足够小，能够一次性读进内存
      并进行排序。

      通过二分搜索加速这个过程。

      在写临时文件的时候，因为瓶颈主要在IO上，因此可以通过压缩的方法减少写的数据量，提升很大（24%）

    * 读取临时文件，根据键值排好序后进行格式转换跟写表。

    优点：
    * 排序只需要读两次，写一次，IO次数较少
    * 易于并行化
    * 提升100%
*** 并行化

    并行读没有效果

    并行写有效果，现在瓶颈在CPU上

    提升（308%）
*** 列值转换
*** 小优化
** 可能的改进
*** 减少copy
    在插入sstable的时候，macro writer调用micro writer的append_row，这个时候micro writer会调用
    copy_append函数将ObDatumRow的数据复制到自己的buffer中。那么其实我们可以跳过
** 总结分析
    1. 新的想法比新的代码更重要
    2. 关注火焰图
    3. 根据各个阶段的瓶颈去优化，不然会浪费较多时间
       多线程读，多线程排序
    4. 先理解代码，再去优化
       微块插入数据的时候会把数据复制到自己的buffer中以供之后的压缩，一开始我没有理解代码，改成复用
       内存中的数据就会出现问题

** 流程图
\begin{tikzpicture}
  \node[draw,rounded corners] (S) at (0,0) {数据};
  \node[draw,rounded corners] (BF1) at (-2,-1.25) {\(B_{1}\)};
  \node (BF2) at (-0.5,-1.25) {\(\cdots\)};
  \node (BF3) at (0.5,-1.25) {\(\cdots\)};
  \node[draw,rounded corners] (BF4) at (2,-1.25) {\(B_{240}\)};
  \draw (-1,-2.5) -- ++(0,-2) -- ++(2,0) -- ++(0,2);
  \foreach \i in {1,...,3}
  \draw (-1, -4.5+\i*0.5) -- +(2,0);
  \node (Q1) at (0, -4.5+0.25) {\(B_{3}\)};
  \node (Q2) at (0, -4.5+0.25+0.5) {\(B_{120}\)};
  \node (Q3) at (0, -4.5+0.25+1) {\(B_{7}\)};
  \node (Q4) at (0, -4.5+0.25+1.6) {\(\vdots\)};
  \draw[->, line width=0.3mm] (1.3, -2.5) -- (1.3, -4.5);
  \node[draw,rounded corners] (G1) at (-6,-6) {\(F_{1}\hspace{0.5cm}\cdots\hspace{0.5cm}F_{30}\)};
  \node[draw,rounded corners] (G2) at (-2.2,-6) {\(F_{31}\hspace{0.5cm}\cdots\hspace{0.5cm}F_{60}\)};
  \node (G3) at (0,-6) {\(\cdots\)};
  \node[draw,rounded corners] (G4) at (2.2,-6) {\(F_{181}\hspace{0.5cm}\cdots\hspace{0.5cm}F_{210}\)};
  \node[draw,rounded corners] (G5) at (6,-6) {\(F_{211}\hspace{0.5cm}\cdots\hspace{0.5cm}F_{240}\)};
  \node[draw,rounded corners] (SS) at (0,-8) {sstable};
  \draw[->] (S) -- (BF1);
  \draw[->] (S) -- (BF4);
  \draw[->] (S) -- (0,-1);
  \node at (3, -0.5) {读线程};
  \node at (4, -3.5) {待处理的buffer队列};
  \node at (6, -5) {写线程};
  \node at (3, -2) {\(B_{i}\)已满};
  \draw[->] (BF1) -- (-0.3,-2.5);
  \draw[->] (BF4) -- (0.3, -2.5);
  \draw[->] (0,-1.4) -- (0, -2.5);
  \draw[->] (-0.4, -4.5) -- (G1);
  \draw[->] (-0.2, -4.5) -- (G2);
  \draw[->] (0.2, -4.5) -- (G4);
  \draw[->] (0.4, -4.5) -- (G5);
  \draw[->] (G1) -- (SS);
  \draw[->] (G2) -- (SS);
  \draw[->] (G4) -- (SS);
  \draw[->] (G5) -- (SS);
  % \draw[->] (G1) -- node[fill=white] {线程1} (SS);
  % \draw[->] (G2) -- node[fill=white] {线程2} (SS);
  % \draw[->] (G4) -- node[fill=white] {线程7} (SS);
  % \draw[->] (G5) -- node[fill=white] {线程8} (SS);
  \node[draw=none,fill=white] at (0,-7) {第\(\lceil i/30\rceil\)个线程在内存中排序\(F_{i}\)并写入sstable};

\end{tikzpicture}
** 提升
    | 59bc | 595861 | improve read                        |      |
    | d7e9 | 587042 | simplies cast                       | 3.4% |
    | 7cf1 | 567588 | no decompress                       | 7.5% |
    | ob2e | 527815 | unfold for                          | 2.8% |
    | 7d5b | 513613 | use 8 thread, sort in single thread | 7.1% |
    | 1333 | 479397 | string_string no copy               | 2.1% |
    | 3fac | 469513 | disable checks in cast              | 3.3% |
    | f846 | 454281 | in memory new row for sort          | 175%, 15.6% |
    | 2c8d | 393007 | bucket sort                         | 136% |
    | a37f | 165165 |                                     |      |
    | ef36 | 135713 |                                     |      |
